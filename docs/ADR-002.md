# ADR-002: CQRS con MediatR

## Estado
Aceptado

## Contexto
Se requiere separar las operaciones de lectura y escritura para:
- Mejorar la claridad del código
- Facilitar el mantenimiento
- Permitir optimizaciones independientes
- Cumplir con los criterios de evaluación que exigen CQRS

## Decisión
Implementar **CQRS (Command Query Responsibility Segregation)** usando **MediatR**:

- **Commands**: Operaciones de escritura (CreateSiniestroCommand)
- **Queries**: Operaciones de lectura (GetSiniestrosQuery, GetSiniestroByIdQuery)
- **Handlers**: Procesadores separados para cada Command/Query
- **MediatR**: Librería que implementa el patrón Mediator para desacoplar Commands/Queries de sus handlers

## Estructura

```
Application/
├── Commands/
│   └── Siniestros/
│       ├── CreateSiniestroCommand.cs
│       └── Handlers/
│           └── CreateSiniestroCommandHandler.cs
└── Queries/
    └── Siniestros/
        ├── GetSiniestrosQuery.cs
        ├── GetSiniestroByIdQuery.cs
        └── Handlers/
            ├── GetSiniestrosQueryHandler.cs
            └── GetSiniestroByIdQueryHandler.cs
```

## Flujo de Ejecución

1. **Controller** recibe request HTTP
2. **Controller** crea Command/Query y lo envía a MediatR
3. **MediatR** encuentra el Handler correspondiente
4. **Handler** ejecuta la lógica de negocio
5. **Handler** retorna resultado al Controller
6. **Controller** retorna respuesta HTTP

## Ejemplo de Uso

```csharp
// Controller
[HttpPost]
public async Task<IActionResult> CreateSiniestro(
    [FromBody] CreateSiniestroDto dto)
{
    var command = new CreateSiniestroCommand { Siniestro = dto };
    var id = await _mediator.Send(command);
    return CreatedAtAction(nameof(GetSiniestroById), new { id }, id);
}

// Handler
public class CreateSiniestroCommandHandler 
    : IRequestHandler<CreateSiniestroCommand, Guid>
{
    public async Task<Guid> Handle(
        CreateSiniestroCommand request, 
        CancellationToken cancellationToken)
    {
        // Lógica de creación
    }
}
```

## Consecuencias

### Positivas
- ✅ Separación clara entre lectura y escritura
- ✅ Controllers más limpios (solo envían mensajes)
- ✅ Fácil agregar nuevos Commands/Queries sin modificar código existente
- ✅ Cumple con principios SOLID (Open/Closed, Single Responsibility)
- ✅ Facilita las pruebas unitarias (mock de MediatR o handlers directamente)
- ✅ Permite agregar comportamientos transversales (logging, validación) mediante Pipeline Behaviors

### Negativas
- ⚠️ Mayor cantidad de archivos (Command + Handler por operación)
- ⚠️ Curva de aprendizaje para desarrolladores no familiarizados con CQRS
- ⚠️ Puede ser "over-engineering" para operaciones muy simples

## Alternativas Consideradas

1. **Patrón Repository Directo en Controllers**
   - Rechazada: No cumple con CQRS
   - Controllers tendrían lógica de negocio mezclada

2. **Service Layer con métodos separados**
   - Considerada pero rechazada: No desacopla tanto como MediatR
   - Requiere inyección directa de servicios en controllers

3. **Event Sourcing**
   - Rechazada: Demasiado complejo para este proyecto
   - No es requerido por los criterios de evaluación

## Referencias

- [MediatR Documentation](https://github.com/jbogard/MediatR)
- [CQRS Pattern - Microsoft](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)
- [CQRS Journey - Microsoft Patterns & Practices](https://learn.microsoft.com/en-us/previous-versions/msp-n-p/jj554200(v=pandp.10))
