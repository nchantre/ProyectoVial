# ADR-004: Repository Pattern

## Estado
Aceptado

## Contexto
Se requiere abstraer el acceso a datos para:
- Facilitar las pruebas unitarias
- Desacoplar la lógica de negocio de la implementación de persistencia
- Permitir cambiar la implementación de acceso a datos sin afectar la lógica de negocio
- Cumplir con principios SOLID (especialmente Dependency Inversion)

## Decisión
Implementar el **Repository Pattern**:

1. **Interfaces en Domain Layer**
   - `ISiniestroRepository` - Define contratos de acceso a datos de siniestros
   - `ICatalogoRepository` - Define contratos de acceso a datos de catálogos

2. **Implementaciones en Infrastructure Layer**
   - `SiniestroRepository` - Implementación usando EF Core
   - `CatalogoRepository` - Implementación usando EF Core

3. **Uso en Application Layer**
   - Los Handlers inyectan las interfaces (no las implementaciones)
   - La lógica de negocio no conoce detalles de persistencia

## Estructura

```
Domain/
└── Interfaces/
    ├── ISiniestroRepository.cs
    └── ICatalogoRepository.cs

Infrastructure/
└── Repositories/
    ├── SiniestroRepository.cs
    └── CatalogoRepository.cs
```

## Ejemplo de Implementación

### Interface (Domain)

```csharp
public interface ISiniestroRepository
{
    Task<Siniestro?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);
    Task<IEnumerable<Siniestro>> GetWithFiltersAsync(
        int? departamentoId = null,
        DateTime? fechaInicio = null,
        DateTime? fechaFin = null,
        int pageNumber = 1,
        int pageSize = 10,
        CancellationToken cancellationToken = default);
    Task<int> CountAsync(
        int? departamentoId = null,
        DateTime? fechaInicio = null,
        DateTime? fechaFin = null,
        CancellationToken cancellationToken = default);
    Task<Guid> AddAsync(Siniestro siniestro, CancellationToken cancellationToken = default);
}
```

### Implementación (Infrastructure)

```csharp
public class SiniestroRepository : ISiniestroRepository
{
    private readonly SiniestrosVialesDbContext _context;

    public SiniestroRepository(SiniestrosVialesDbContext context)
    {
        _context = context;
    }

    public async Task<Siniestro?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Siniestros
            .Include(s => s.Departamento)
            .Include(s => s.Ciudad)
            .Include(s => s.TipoSiniestro)
            .Include(s => s.Vehiculos)
            .FirstOrDefaultAsync(s => s.Id == id, cancellationToken);
    }
    // ... más métodos
}
```

### Uso en Handler (Application)

```csharp
public class GetSiniestrosQueryHandler : IRequestHandler<GetSiniestrosQuery, PagedResult<SiniestroDto>>
{
    private readonly ISiniestroRepository _repository; // Interface, no implementación
    private readonly IMapper _mapper;

    public GetSiniestrosQueryHandler(ISiniestroRepository repository, IMapper mapper)
    {
        _repository = repository;
        _mapper = mapper;
    }

    public async Task<PagedResult<SiniestroDto>> Handle(GetSiniestrosQuery request, CancellationToken cancellationToken)
    {
        var siniestros = await _repository.GetWithFiltersAsync(
            request.DepartamentoId,
            request.FechaInicio,
            request.FechaFin,
            request.PageNumber,
            request.PageSize,
            cancellationToken);
        // ... más lógica
    }
}
```

## Consecuencias

### Positivas
- ✅ Desacopla la lógica de negocio de la implementación de persistencia
- ✅ Facilita las pruebas unitarias (mock de interfaces)
- ✅ Permite cambiar la implementación sin afectar la lógica de negocio
- ✅ Cumple con Dependency Inversion Principle (SOLID)
- ✅ Abstrae la complejidad de EF Core de la capa de aplicación
- ✅ Facilita agregar caché, logging, etc. sin modificar handlers

### Negativas
- ⚠️ Agrega una capa de abstracción adicional
- ⚠️ Puede ser "over-engineering" para operaciones muy simples
- ⚠️ Requiere mantener interfaces y implementaciones sincronizadas

## Alternativas Consideradas

1. **Usar DbContext directamente en Handlers**
   - Rechazada: Viola Clean Architecture (Application dependería de Infrastructure)
   - Dificulta las pruebas unitarias
   - Acopla la lógica de negocio a EF Core

2. **Unit of Work Pattern**
   - Considerada pero rechazada: Más complejo de lo necesario
   - Este proyecto no requiere transacciones complejas
   - Repository Pattern es suficiente

3. **Specification Pattern**
   - Considerada pero rechazada: Aumenta la complejidad
   - Los filtros son simples y no justifican el patrón
   - Se puede agregar en el futuro si es necesario

## Ventajas para Pruebas

Con Repository Pattern, las pruebas unitarias son simples:

```csharp
// Prueba unitaria
var mockRepository = new Mock<ISiniestroRepository>();
mockRepository
    .Setup(r => r.GetByIdAsync(It.IsAny<Guid>()))
    .ReturnsAsync(new Siniestro(...));

var handler = new GetSiniestroByIdQueryHandler(mockRepository.Object, mapper);
// ... test
```

## Referencias

- [Repository Pattern - Microsoft](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design)
- [Repository Pattern - Martin Fowler](https://martinfowler.com/eaaCatalog/repository.html)
- [Clean Architecture - Repository Pattern](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
