# ADR-004: Repository Pattern

## Estado
Aceptado

## Contexto
Se requiere abstraer el acceso a datos para:
- Facilitar las pruebas unitarias
- Desacoplar la lógica de negocio de la implementación de persistencia
- Permitir cambiar la implementación de acceso a datos sin afectar la lógica de negocio
- Cumplir con principios SOLID (especialmente Dependency Inversion)

## Decisión
Implementar el **Repository Pattern**:

1. **Interfaces en Domain Layer**
   - `ISiniestroRepository` - Define contratos de acceso a datos de siniestros
   - `ICatalogoRepository` - Define contratos de acceso a datos de catálogos

2. **Implementaciones en Infrastructure Layer**
   - `SiniestroRepository` - Implementación usando EF Core
   - `CatalogoRepository` - Implementación usando EF Core

3. **Uso en Application Layer**
   - Los Handlers inyectan las interfaces (no las implementaciones)
   - La lógica de negocio no conoce detalles de persistencia

## Estructura

```
Domain/
└── Interfaces/
    ├── ISiniestroRepository.cs
    └── ICatalogoRepository.cs

Infrastructure/
└── Repositories/
    ├── SiniestroRepository.cs
    └── CatalogoRepository.cs
```

## Ejemplo de Implementación

### Interface (Domain)

```csharp
public interface ISiniestroRepository
{
    Task<Siniestro?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default);
    Task<IEnumerable<Siniestro>> GetWithFiltersAsync(
        int? departamentoId = null,
        DateTime? fechaInicio = null,
        DateTime? fechaFin = null,
        int pageNumber = 1,
        int pageSize = 10,
        CancellationToken cancellationToken = default);
    Task<int> CountAsync(
        int? departamentoId = null,
        DateTime? fechaInicio = null,
        DateTime? fechaFin = null,
        CancellationToken cancellationToken = default);
    Task<Guid> AddAsync(Siniestro siniestro, CancellationToken cancellationToken = default);
}
```

### Implementación (Infrastructure)

```csharp
public class SiniestroRepository : ISiniestroRepository
{
    private readonly SiniestrosVialesDbContext _context;

    public SiniestroRepository(SiniestrosVialesDbContext context)
    {
        _context = context;
    }

    public async Task<Siniestro?> GetByIdAsync(Guid id, CancellationToken cancellationToken = default)
    {
        return await _context.Siniestros
            .Include(s => s.Departamento)
            .Include(s => s.Ciudad)
            .Include(s => s.TipoSiniestro)
            .Include(s => s.Vehiculos)
            .FirstOrDefaultAsync(s => s.Id == id, cancellationToken);
    }
    // ... más métodos
}
```

### Uso en Handler (Application)

```csharp
public class GetSiniestrosQueryHandler : IRequestHandler<GetSiniestrosQuery, PagedResult<SiniestroDto>>
{
    private readonly ISiniestroRepository _repository; // Interface, no implementación
    private readonly IMapper _mapper;

    public GetSiniestrosQueryHandler(ISiniestroRepository repository, IMapper mapper)
    {
        _repository = repository;
        _mapper = mapper;
    }

    public async Task<PagedResult<SiniestroDto>> Handle(GetSiniestrosQuery request, CancellationToken cancellationToken)
    {
        var siniestros = await _repository.GetWithFiltersAsync(
            request.DepartamentoId,
            request.FechaInicio,
            request.FechaFin,
            request.PageNumber,
            request.PageSize,
            cancellationToken);
        // ... más lógica
    }
}
```

