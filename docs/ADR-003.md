# ADR-003: Entity Framework Core con Database First (sin migraciones)

## Estado
Aceptado

## Contexto
Se requiere implementar acceso a datos para la API de siniestros viales. Las opciones principales son:
- Entity Framework Core (ORM)
- ADO.NET (acceso directo a BD)
- Dapper (micro-ORM)

Además, se debe decidir entre:
- Code First (EF Core crea la BD)
- Database First (BD existe, EF Core se conecta)

## Decisión
Usar **Entity Framework Core 8.0** con enfoque **Database First** (sin migraciones):

1. La base de datos se crea **manualmente** ejecutando scripts SQL
2. EF Core se configura para **conectarse a la BD existente**
3. **NO se usan migraciones** de EF Core
4. Las configuraciones de entidades se hacen mediante **Fluent API**

## Razones

### Por qué EF Core (vs ADO.NET/Dapper)
- ✅ Mejor integración con Clean Architecture y DDD
- ✅ Soporte nativo para relaciones y navegación
- ✅ Type-safe queries con LINQ
- ✅ Cambio de tracking (AsNoTracking) para mejor rendimiento
- ✅ Facilita el uso de Value Objects y entidades ricas
- ✅ Soporte para Include() para cargar relaciones

### Por qué Database First (vs Code First)
- ✅ Control total sobre el esquema de la base de datos
- ✅ Permite optimizaciones específicas de SQL Server (índices, constraints)
- ✅ Scripts SQL son versionables y auditable
- ✅ Facilita la creación de índices compuestos y optimizaciones avanzadas
- ✅ No requiere conocimiento de migraciones de EF Core

### Por qué sin migraciones
- ✅ La BD se crea una vez con scripts SQL
- ✅ Evita complejidad de migraciones en desarrollo
- ✅ Scripts SQL son más explícitos y controlables
- ✅ Facilita el despliegue en diferentes entornos

## Implementación

### 1. Scripts SQL
```
Scripts/
├── 01_CreateDatabase.sql    # Crear BD
├── 02_CreateTables.sql       # Crear tablas
├── 03_CreateIndexes.sql      # Crear índices
└── 04_InsertSampleData.sql   # Datos de ejemplo (opcional)
```

### 2. Configuración EF Core

```csharp
// Program.cs
builder.Services.AddDbContext<SiniestrosVialesDbContext>(options =>
    options.UseSqlServer(connectionString));
```

### 3. Configuraciones Fluent API

```csharp
// Infrastructure/Data/Configurations/SiniestroConfiguration.cs
public class SiniestroConfiguration : IEntityTypeConfiguration<Siniestro>
{
    public void Configure(EntityTypeBuilder<Siniestro> builder)
    {
        builder.ToTable("Siniestros");
        builder.HasKey(s => s.Id);
        // ... más configuraciones
    }
}
```

## Consecuencias

### Positivas
- ✅ Control total sobre el esquema de BD
- ✅ Scripts SQL versionables y auditable
- ✅ Facilita optimizaciones de BD (índices, constraints)
- ✅ No requiere conocimiento de migraciones
- ✅ Facilita el despliegue (solo ejecutar scripts)

### Negativas
- ⚠️ Cambios en BD requieren modificar scripts SQL manualmente
- ⚠️ No hay sincronización automática entre código y BD
- ⚠️ Requiere disciplina para mantener scripts actualizados
- ⚠️ Cambios en esquema requieren actualizar configuraciones Fluent API

## Alternativas Consideradas

1. **Code First con Migraciones**
   - Considerada pero rechazada: Más complejo para este proyecto
   - Requiere conocimiento de migraciones de EF Core
   - Menos control sobre el esquema final

2. **ADO.NET**
   - Considerada pero rechazada: Más código boilerplate
   - No aprovecha las ventajas de un ORM
   - Dificulta el uso de Value Objects y entidades ricas

3. **Dapper**
   - Considerada pero rechazada: Requiere más código manual
   - No tiene soporte nativo para relaciones complejas
   - Menos integración con DDD

## Referencias

- [Entity Framework Core - Database First](https://learn.microsoft.com/en-us/ef/core/get-started/overview/first-app?tabs=netcore-cli)
- [Fluent API - EF Core](https://learn.microsoft.com/en-us/ef/core/modeling/)
- [Database First vs Code First](https://www.entityframeworktutorial.net/efcore/entity-framework-core-dbcontext.aspx)
